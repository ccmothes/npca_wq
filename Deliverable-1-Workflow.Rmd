---
title: "Deliverable-1-Workflow"
author: "Katie Willi"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(sf)
library(mapview)
map(list.files('src', full.names = TRUE), source)
```

This document represents the workflow to access the EPA's ATTAINS water quality status database and relate it to units within the National Park Service (NPS) system. 

# 1. Pull in relevant data sets.

### 1a. Download ATTAINS geospatial data.

```{r}
## Download the ATTAINS geodatabase on the EPA's website,
## select where you want it to be saved:
#  getATTAINS(path = 'data/ATTAINS')

# Load in all geospatial layers within the ATTAINS geodatabase:
attains_areas <- loadATTAINS(path = 'data/ATTAINS', layer = "attains_au_areas")

attains_lines <- loadATTAINS(path = 'data/ATTAINS', layer = "attains_au_lines")

attains_points <- loadATTAINS(path = 'data/ATTAINS', layer = "attains_au_points")

attains_catchments <-  loadATTAINS(path = 'data/ATTAINS', layer = "attains_au_catchments")

# Load in ATTAINS WQS Parameters:
attains_assmnt_parms <- loadATTAINS(path = 'data/ATTAINS', layer = "attains_au_assmnt_parms")
```

### 1b. Download NPS Park Boundaries.

```{r}
# Download the Park Boundary dataset from the NPS's API:
# parks <- getParkUnits(projection = 3857)
```

### 1c. Load in NHD Plus V2 Catchments.

```{r}
#contus_catchments <- loadCatchments(projection = 3857)
contus_catchments <- readRDS('data/nhdplus_contus_catchments_3857.RDS')
```

### 1d. Load in NPCA Regions.

```{r}
npca_regions <- getNPCA(projection = 3857)
```

We now have all the data we need to make our assessment on NPS water quality status!

# 2. Aggregate data by assessment unit + park

### 2a. Subset and clip the ATTAINS geospatial data to only include assessment units within NPS Park Boundaries

```{r}
nps_attains_areas <- attains_areas %>% 
  subsetATTAINSpark(layer = ., type = "area")

nps_attains_lines <- attains_lines %>%
  subsetATTAINSpark(layer = ., type = "line")

nps_attains_points <- attains_points %>%
  subsetATTAINSpark(layer = ., type = "point")
```

### 2b. Combine all of this data into a single file.

```{r}
all_nps_aus <- aggregateATTAINSpark(path = 'data/')
```

### 2c. Link each assessment unit to all of its water quality assessment data
```{r}
final_dataset_park <- all_nps_aus %>%
  getWQS()
```

# 3. Aggregate by assessment unit + catchment + park. (CONTUS ONLY!)

### 3a. Subset and clip the NHD Plus V2 catchment layer to only include catchments within NPS Park Boundaries.

```{r}
# nps_all_catchments <- contus_catchments %>%
#   subsetCatchments(layer = .) #%>%
  #dplyr::filter(!state %in% c("AK", "GU", "HI", "VI", "PR", "AS"))

nps_all_catchments <- readRDS('data/00_nps_all_catchments.RDS')
```

### 3b. Subset and clip the ATTAINS geospatial data to only include assessment units within clipped catchments inside NPS Park Boundaries

```{r}
nps_attains_areas <- attains_areas %>% 
  subsetATTAINS(layer = ., type = "area") %>%
  dplyr::filter(!state %in% c("AK", "GU", "HI", "VI", "PR", "AS"))

nps_attains_lines <- attains_lines %>%
  subsetATTAINS(layer = ., type = "line") %>%
  dplyr::filter(!state %in% c("AK", "GU", "HI", "VI", "PR", "AS"))

nps_attains_points <- attains_points %>%
  subsetATTAINS(layer = ., type = "point") %>%
  dplyr::filter(!state %in% c("AK", "GU", "HI", "VI", "PR", "AS"))
```

### 2e. Combine all of this data into a single file.

```{r}
all_nps_aus <- aggregateATTAINS(path = 'data/')
```

### 2f. Link this data to their associated catchment polygons for future "navigating" steps.

```{r}
nps_attains_to_catchments <- all_nps_aus %>%
  catchmentizeATTAINS(layer = ., path = 'data/')
```

### 3. Link each assessment unit to all of its water quality assessment data
```{r}
final_dataset_catchment <- nps_attains_to_catchments %>%
  getWQS()
```

# 4. QA: Ground-truth that the above workflow is producing what we would expect.

### 4a. Does our catchment polygon layer represent what we are hoping for it to?

```{r}
test <- nps_attains_to_catchments %>% filter(UNIT_CODE == "ROMO")

mapview(test) + mapview(attains_areas[test,]) + mapview(attains_lines[test,])
```

... it appears that it is. See how there are duplicate catchments in locations where there are more than one assessment unit overlaying them? This is what we would expect.

### 4b. What locations are included in `final_dataset_catchments` that are not included in `final_dataset_parks`? These SHOULD only be locations where there is a catchment without any assessment units within it.

```{r}
missing_in_parks <- final_dataset_catchment %>% 
  distinct(UNIT_CODE, assessmentunitidentifier, .keep_all = TRUE) %>%
  anti_join(., final_dataset_park, by = c("UNIT_CODE", "assessmentunitidentifier"))
```

How many of these missing objects don't have any assessment unit in them?

```{r}
nrow(
  missing_in_parks %>%
    filter(is.na(assessmentunitidentifier))
)
```

... all of them! That is a good sign. This means that all of the catchment + park combos in this data set don't seem to have any ATTAINS assessment units within them. Therefore, they would not be represented in our `final_dataset_park` object, anyways. Let's double check this by trying to re-find ATTAINS features within these catchments:

```{r}
test <- nps_attains_to_catchments %>% 
  dplyr::filter(is.na(assessmentunitidentifier)) %>%
  dplyr::group_by(assessmentunitidentifier, UNIT_CODE) %>%
  dplyr::summarize(count = n())

a <- attains_areas[test,]
b <- attains_lines[test,]
c <- attains_points[test,]

park_test <- parks[test,]

mapview(test) + mapview(park_test, col.regions = "#F0E442")

gc()
```

My theory seems correct! (Note that the Alaska KLGO park unit also has an office in Seattle, hence why that lil' blob in Alaska shows up).


### 4c. What locations are included in `final_dataset_parks` that are not included in `final_dataset_catchments`?

```{r}
missing_in_catchments <- final_dataset_park %>% 
  # filter(!is.na(assessmentunitidentifier)) %>%
  distinct(UNIT_CODE, assessmentunitidentifier, .keep_all = TRUE) %>%
  anti_join(., final_dataset_catchment, by = c("UNIT_CODE","assessmentunitidentifier"))
```

Where are these sites located?

```{r}
unique(missing_in_catchments$assessment_type)

missing_lines <- attains_lines %>%
  dplyr::filter(assessmentunitidentifier %in% missing_in_catchments$assessmentunitidentifier)
missing_areas <- attains_areas %>%
  filter(assessmentunitidentifier %in% missing_in_catchments$assessmentunitidentifier)
missing_points <- attains_points %>%
  filter(assessmentunitidentifier %in% missing_in_catchments$assessmentunitidentifier)
```

All of these locations are either not in CONTUS (and therefore they wouldn't have an associated catchment to be represented by in `final_dataset_catchment`) OR they are along the coast of CONTUS and probably also don't have an overlapping catchment. This is what we would expect, but also exposes something wrong with our workflow. We will need to add the pseudo-catchments that were created for these assessment units into this dataset, using the `attains_catchment` layer:

```{r}
new_catch_lines <- missing_lines %>%
  pseudoATTAINSsubset(layer = ., type = "line")

new_catch_areas <- missing_areas %>%
  pseudoATTAINSsubset(layer = ., type = "area")

new_catch_points <- 
  missing_points %>%
  pseudoATTAINSsubset(layer = ., type = "point")

new_nps_aus <- pseudoATTAINSaggregate(path = 'data/')

new_attains_to_catchments <- new_nps_aus %>%
  pseudoATTAINScatchmentize(layer = ., path = 'data/') %>%
.[parks,]

mapview(new_attains_to_catchments)
```

Add this new assessment unit data to the old data sets:
```{r}
new_nps_attains_to_catchments <- nps_attains_to_catchments %>%
  bind_rows(new_attains_to_catchments)

new_final_dataset_catchment <- new_nps_attains_to_catchments %>%
  getWQS() %>%
  dplyr::filter(state %in% c("AK", "GU", "HI", "VI", "PR", "AS"))
```


# 5. Save objects we will use in later workflows. 
```{r}
save(new_nps_attains_to_catchments, final_dataset_park, new_final_dataset_catchment,
     # raw features:
     attains_areas, attains_points, attains_lines, contus_catchments, attains_catchments,
     file = "data/alldata.RData")
# remove those that are completely unuseful if we are moving immediately to next RMD:
rm(a,b,c,test,missing_in_parks,all_nps_aus, final_dataset_catchment, missing_areas, missing_in_catchments, missing_in_parks, missing_lines,
   missing_points, new_catch_areas, new_catch_lines, new_catch_points, new_attains_to_catchments, new_nps_aus, npca_regions, park_test,
   nps_attains_to_catchments)

```

